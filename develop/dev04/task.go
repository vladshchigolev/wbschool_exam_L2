/*
=== Поиск анаграмм по словарю ===

Напишите функцию поиска всех множеств анаграмм по словарю.
Например:
'пятак', 'пятка' и 'тяпка' - принадлежат одному множеству,
'листок', 'слиток' и 'столик' - другому.

Входные данные для функции: ссылка на массив - каждый элемент которого - слово на русском языке в кодировке utf8.
Выходные данные: Ссылка на мапу множеств анаграмм.
Ключ - первое встретившееся в словаре слово из множества
Значение - ссылка на массив, каждый элемент которого, слово из множества. Массив должен быть отсортирован по возрастанию.
Множества из одного элемента не должны попасть в результат.
Все слова должны быть приведены к нижнему регистру.
В результате каждое слово должно встречаться только один раз.

Программа должна проходить все тесты. Код должен проходить проверки go vet и golint.
*/

package main

import (
"fmt"
"sort"
"strings"
)

// SortCharsInWord сортирует символы в слове
func SortCharsInWord(s string) string {
	s = strings.ToLower(s) // Приводим все символы в слове к нижнему регистру
	container := strings.Split(s, "") // Разбиваем слово на отдельные буквы, ...
	sort.Strings(container) // ... сортируем буквы из слова, ...
	return strings.Join(container, "") // ... а затем соединяем буквы обратно в слово.
}

// BuiltSet формирует слайс только из уникальных значений
func BuiltSet(bucket []string) []string {
	// Реализовали set
	set := make(map[string]bool)
	var setToSlice []string
	for _, v := range bucket {
		v = strings.ToLower(v)
		set[v] = true
	}
	for i := range set {
		setToSlice = append(setToSlice, i)
	}
	sort.Strings(setToSlice)
	return setToSlice
}

// Функция printAnagrams предназначена для красивой печати
func printAnagrams(bucket map[string][]string) {
	for k, v := range bucket {
		fmt.Printf("%v : %v\n", k, v)
	}
}

// FindAnagrams ищет анаграммы в исходном массиве, возвращает мапу множеств анаграмм
func FindAnagrams(arr []string) map[string][]string {
	bucket := make(map[string][]string, 0)  // Промежуточная мапа для элементов, распределенных по множествам (значения по ключу могут повторяться (условие, что каждый эл-т в мн-ве - уникальный, может не выполняться))
	keys := make(map[string][]int, 0) // Промежуточная мапа для позиций элементов одного множества в исходном массиве
	res := make(map[string][]string, 0) // Результирующая мапа, где все анаграммы распределены по соответствующим множествам
	setsNames := make([]string, 0)
	// Если в исходном массиве будут попадаться слова, являющиеся анаграммами по отношению друг к другу (то есть в отсортированном по буквам виде эти слова будут представлять одинаковые значения),
	// мы добавим их (и их индексы в исходном массиве) по одному и тому же ключу в мапу (пятак, пятка и тяпка будут добавлены в мапу (в слайс строк) по ключу "акптя")
	for i, v := range arr { // Перебираем слова
		charBase := SortCharsInWord(v) // Сортируем каждое слово по буквам
		fmt.Println(charBase)
		keys[charBase] = append(keys[charBase], i) // Добавляем в мапу (в слайс интов) элемент по ключу.
		bucket[charBase] = append(bucket[charBase], v)
		// На этом этапе слова уже распределены по множествам, но:
		// 1. В каждом из множеств могут встречаться повторения
		// 2. Ключи пока - наборы букв из этих анаграмм, а не первое встретившееся в словаре слово из множества
	}

	for k, _ := range bucket { // Добавляем ключи в слайс строк
		fmt.Println("k:", k)
		setsNames = append(setsNames, k)
	}

	for _, setName := range setsNames {
		min := keys[setName][0] // Находим для 1-го элемента из одного из сформированных множеств его позицию в исходном массиве строк ("первый встретившийся" из условия)
		res[(arr)[min]] = BuiltSet(bucket[setName]) // BuiltSet вернёт слайс уникальных значений, его мы запишем в мапу по ключу, являющемуся первым встретившимся словом из данного множества
	}

	return res
}

func main() {
	words := []string{"ПЯТка", "пятак", "тяпка", "ЛИСТОК", "слиток", "столик", "листок"}
	anagrams := FindAnagrams(words)
	printAnagrams(anagrams)
}
