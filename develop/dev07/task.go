/*
=== Or channel ===

Реализовать функцию, которая будет объединять один или более done каналов в single канал если один из его составляющих каналов закроется.
Одним из вариантов было бы очевидно написать выражение при помощи select, которое бы реализовывало эту связь,
однако иногда неизестно общее число done каналов, с которыми вы работаете в рантайме.
В этом случае удобнее использовать вызов единственной функции, которая, приняв на вход один или более or каналов, реализовывала весь функционал.

Определение функции:
var or func(channels ...<- chan interface{}) <- chan interface{}

Пример использования функции:
sig := func(after time.Duration) <- chan interface{} {
	c := make(chan interface{})
	go func() {
		defer close(c)
		time.Sleep(after)
}()
return c
}

start := time.Now()
<-or (
	sig(2*time.Hour),
	sig(5*time.Minute),
	sig(1*time.Second),
	sig(1*time.Hour),
	sig(1*time.Minute),
)

fmt.Printf(“done after %v”, time.Since(start))
*/

package main
//  Есть способ установить коммуникацию между родительской горутиной и ее дочерними горутинами, который позволяет родителю отправить сигнал
//  о прерывании выполнения (упразднении) своим дочерним элементам. По соглашению, этот сигнал обычно является каналом только для
//  чтения с именем "done". Родительская горутина передает этот канал дочерней горутине, а затем закрывает канал, когда хочет
//  "упразднить" дочернюю горутину.
//  В данном случае мы пытаемся объединить один или несколько done-каналов в один done-канал, который закрывается, если закрывается какой-либо
//  из составляющих его каналов.
import (
"fmt"
"time"
)
// Функция, объединяющая один или несколько done-каналов в один done-канал
func or(channs ...<-chan interface{}) <-chan interface{} { // вход: слайс (переменной длины) каналов любого типа, выход: один канал
	// Поскольку это рекурсивная функция, мы должны установить критерии завершения (определить крайний случай рекурсии).
	switch len(channs) {
	case 0: // Если в функцию не было передано ни одного канала,
		return nil // вернём nil channel
	case 1: // второй критерий завершения гласит, что если наш слайс содержит только один элемент, мы просто возвращаем этот элемент
		return channs[0]
	}
	// Дальше рассматриваем ситуации, когда каналов в функцию передано больше одного
	orDone := make(chan interface{})
	go func() { // создаем горутину, чтобы мы могли ждать сообщений на наших каналах без блокировки
		defer close(orDone)

		switch len(channs) {
		// Если в ф-ю передано 2 канала, используем select case, чтобы читать из того канала, который готов передать значение
		// В качестве оптимизации, чтобы ограничить количество запускаемых горутин, мы помещаем здесь особый случай для
		// вызовов or только с двумя каналами
		case 2:
			select {
			case <-channs[0]: // Читаем значение из канала
			case <-channs[1]:
			}
		// В остальных случаях (каналов больше двух)
		default:
			select {
			case <-channs[0]:
			case <-channs[1]:
			case <-channs[2]:
			case <-or(append(channs[3:], orDone)...): // Рекурсивно создаем or-канал из всех каналов в срезе после третьего индекса
													  // Каждый рекурсивный вызов обрабатывает максимум по 3 канала,
													  // после чего происходит новый рекурсивный вызов. Крайним случаем будет
													  // вызов or с кол-вом каналов, не превышающих 3
			// Здесь мы рекурсивно создаем or-канал из всех каналов в нашем слайсе после третьего индекса
			// Если закроется какой-то из каналов внутри функции, вызванной рекурсивно (на любом уровне рекурсии), закроется и этот канал
			}
		}
	}()
	return orDone
}

func main() {
	sig := func(after time.Duration) <-chan interface{} { // sig создаёт канал, из которого можно только читать, возвращает его.
		c := make(chan interface{})						  // также она запускает в новой горутине функцию, которая по истечении
		go func() {										  // определённого времени закрывает этот канал
			defer close(c)
			time.Sleep(after)
		}()
		return c
	}

	start := time.Now()
	<-or( // Ф-я or принимает на вход мн-во каналов, которые будут закрыты через какое-то время (секунду, минуту, 5 минут и т. д.)
		sig(2*time.Hour), // создать канал, вернуть его, закрыть его через 2 часа
		sig(5*time.Minute),
		sig(1*time.Second),
		sig(1*time.Hour),
		sig(1*time.Minute), // создать канал, вернуть его, закрыть его через 1 минуту
	)
	// Канал, возвращённый ф-ей or закроется, когда закроется первый из каналов, который её был передан (в нашем случае это ~1 секунда)
	fmt.Printf("done after %v\n", time.Since(start))
}
