package main

import (
	"fmt"
	"math/rand"
	"time"
)
// Что происходит: в main-горутине дважды вызывается функция, в которой:
// 1. создается небуферизованный канал
// 2. в новой горутине вызывается функция, перебирающая в цикле элементы массива и отправляющая их значения по созданному каналу
func asChan(vs ...int) <-chan int { // Функция возвращает канал, по которому она отправляет значения
									// На вызывающей стороне из канала можно ТОЛЬКО ЧИТАТЬ
									// Зачем вообще возвращать канал? - Чтобы писать в канал или читать из него, нужно, во-первых, иметь к нему доступ (ссылку на структуру)
									// длина массива vs определяется количеством инициализаторов
	c := make(chan int) // c - локальная переменная
	//fmt.Println(reflect.TypeOf(vs))
	go func() {
		for _, v := range vs {
			c <- v // Выполняем операцию отправки по каналу (данная горутина заблокируется, пока значение не будет получено)
			time.Sleep(time.Duration(rand.Intn(1000)) * time.Millisecond) // Вызываем time.Sleep
		}

		close(c) // после успешного отправления (буфер = 0) закрываем канал, чтобы получающая горутина (если получение огранизовано в цикле) не заблокировалась навсегда
	}()
	return c // Возвращаем канал
}
// В какой-то момент горутины, созданные в функциях asChan отправив первые значения (первую пару: каждая горутина по одному значению) по своим каналам заблокируются,
// ожидая получения значения кем-нибудь
// Слияние каналов
func merge(a, b <-chan int) <-chan int { // вход: 2 канала "только для чтения", выход: канал, в который будем производить слияние
	c := make(chan int) // в этот канал будем сливать
	go func() { //
		for {	// Каждая итерация цикла должна ожидать события от одного из двух каналов.
				// Инструкция select ожидает, когда связь для некоторого варианта будет готова к
				// обработке. Затем она выполняет операцию связи и выполняет инструкции из блока
				// для данного варианта. Операции прочих связей не происходят.
			select {
				case v := <-a: // Если готовы несколько вариантов, select выбирает один из них случайным образом
					c <- v // пишет значение, прочитанное из канала "a", в канал "c"
				case v := <-b:
					c <- v // аналогично
				// Здесь проблема в том, что данная горутина (т к цикл бесконечный) будет читать значения из канала даже когда отправляющая горутина ЗАКРОЕТ канал (в этом случае будет получать
				// нулевые значения)
			}
		}
	}()
	return c
}

func main() {
    // Здесь вызовы asChan и merge синхронны (конец выполения 1-ой совпадает с началом 2-ой)
	a := asChan(1, 3, 5, 7) // asChan вернула канал
	b := asChan(2, 4 ,6, 8)
	c := merge(a, b)
	for v := range c { //
		fmt.Println(v)
	}
}